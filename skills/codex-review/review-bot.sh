#!/usr/bin/env bash
set -euo pipefail

if ! command -v rg >/dev/null 2>&1; then
  echo "Error: ripgrep (rg) is required." >&2
  exit 1
fi

TARGET="${1:-.}"
shift || true
OUT_PATH=""
RUN_COMMANDS="false"

while [ "${1:-}" != "" ]; do
  case "$1" in
    --out)
      OUT_PATH="${2:-}"
      shift 2
      ;;
    --run)
      RUN_COMMANDS="true"
      shift
      ;;
    *)
      echo "Unknown option: $1" >&2
      exit 1
      ;;
  esac
done

if [ ! -d "$TARGET" ]; then
  echo "Error: target not found: $TARGET" >&2
  exit 1
fi

JSON_TMP="$(mktemp)"
cleanup() { rm -f "$JSON_TMP"; }
trap cleanup EXIT

json_quote() {
  if command -v python3 >/dev/null 2>&1; then
    python3 -c 'import json,sys; print(json.dumps(sys.stdin.read()))'
  else
    sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e ':a;N;$!ba;s/\n/\\n/g'
  fi
}

count_files() {
  local patterns=("$@")
  (rg --files "${patterns[@]}" \
    --glob '!node_modules/**' \
    --glob '!dist/**' \
    --glob '!build/**' \
    --glob '!coverage/**' \
    2>/dev/null || true) \
    | wc -l | tr -d ' '
}

collect_matches() {
  local pattern="$1"
  shift
  local globs=("$@")
  rg -n --no-heading "$pattern" \
    --glob '!node_modules/**' \
    --glob '!dist/**' \
    --glob '!build/**' \
    --glob '!coverage/**' \
    --glob '!.qodana/**' \
    --glob '!.claude/**' \
    --glob '!.git/**' \
    --glob '!package-lock.json' \
    --glob '!*.lock' \
    "${globs[@]}" \
    || true
}

bool_from_file() {
  if [ -f "$1" ]; then
    echo "true"
  else
    echo "false"
  fi
}

pushd "$TARGET" >/dev/null

has_package_json=$(bool_from_file "package.json")
has_tsconfig=$(bool_from_file "tsconfig.json")
has_angular=$(bool_from_file "angular.json")
has_pom=$(bool_from_file "pom.xml")
has_gradle=$(bool_from_file "build.gradle")
has_gradle_kts=$(bool_from_file "build.gradle.kts")

count_ts=$(count_files -g "**/*.ts" -g "**/*.tsx")
count_js=$(count_files -g "**/*.js" -g "**/*.jsx" -g "**/*.mjs" -g "**/*.cjs")
count_java=$(count_files -g "**/*.java")
count_sql=$(count_files -g "**/*.sql")
count_docs=$(count_files -g "**/*.md" -g "README*" -g "CHANGELOG*" -g "LICENSE*")
count_tests=$(count_files -g "**/*test*.*" -g "**/*spec*.*" -g "test/**/*.*" -g "tests/**/*.*")

is_node_ts="false"
is_java="false"
if [ "$has_package_json" = "true" ] || [ "$count_ts" -gt 0 ] || [ "$count_js" -gt 0 ] || [ "$has_angular" = "true" ]; then
  is_node_ts="true"
fi
if [ "$has_pom" = "true" ] || [ "$has_gradle" = "true" ] || [ "$has_gradle_kts" = "true" ] || [ "$count_java" -gt 0 ]; then
  is_java="true"
fi

security_patterns=()
security_patterns+=("eval\\(")
security_patterns+=("Function\\(")
security_patterns+=("innerHTML\\s*=")
security_patterns+=("document\\.write\\(")
security_patterns+=("dangerouslySetInnerHTML")
security_patterns+=("Runtime\\.getRuntime\\(\\)\\.exec")
security_patterns+=("ProcessBuilder\\(")
security_patterns+=("setAccessible\\(true\\)")
security_patterns+=("Statement\\.execute\\(")
security_patterns+=("SELECT\\s+\\*")

ai_smell_patterns=()
ai_smell_patterns+=("Generated by")
ai_smell_patterns+=("ChatGPT")
ai_smell_patterns+=("OpenAI")
ai_smell_patterns+=("Copilot")
ai_smell_patterns+=("LLM")

quality_patterns=()
quality_patterns+=("TODO")
quality_patterns+=("FIXME")
quality_patterns+=("HACK")
quality_patterns+=("XXX")

security_hits=()
for p in "${security_patterns[@]}"; do
  while IFS= read -r line; do
    [ -n "$line" ] && security_hits+=("$line")
  done < <(collect_matches "$p" -g "**/*.*")
done

ai_smell_hits=()
for p in "${ai_smell_patterns[@]}"; do
  while IFS= read -r line; do
    [ -n "$line" ] && ai_smell_hits+=("$line")
  done < <(collect_matches "$p" -g "**/*.*")
done

quality_hits=()
for p in "${quality_patterns[@]}"; do
  while IFS= read -r line; do
    [ -n "$line" ] && quality_hits+=("$line")
  done < <(collect_matches "$p" -g "**/*.*")
done

commands_run=()
commands_output=()
if [ "$RUN_COMMANDS" = "true" ]; then
  if [ "$has_package_json" = "true" ]; then
    if rg -q "\"lint\"\\s*:" package.json; then
      commands_run+=("npm run lint")
      commands_output+=("$(npm run lint 2>&1 || true)")
    fi
    if rg -q "\"test\"\\s*:" package.json; then
      commands_run+=("npm test")
      commands_output+=("$(npm test 2>&1 || true)")
    fi
  fi
  if [ "$has_pom" = "true" ]; then
    commands_run+=("mvn -q test")
    commands_output+=("$(mvn -q test 2>&1 || true)")
  fi
  if [ "$has_gradle" = "true" ] || [ "$has_gradle_kts" = "true" ]; then
    commands_run+=("./gradlew test")
    commands_output+=("$(./gradlew test 2>&1 || true)")
  fi
fi

join_array_json() {
  local arr_name="$1"
  eval "local items=(\"\${${arr_name}[@]}\")" 2>/dev/null
  if [ "${#items[@]}" -eq 0 ]; then
    echo "[]"
    return
  fi
  local out="["
  local first="true"
  for item in "${items[@]}"; do
    if [ "$first" = "true" ]; then
      first="false"
    else
      out+=","
    fi
    out+=$(printf "%s" "$item" | json_quote)
  done
  out+="]"
  echo "$out"
}

{
  echo "{"
  echo "  \"target\": $(printf "%s" "$TARGET" | json_quote),"
  echo "  \"detected\": {"
  echo "    \"package_json\": $has_package_json,"
  echo "    \"tsconfig\": $has_tsconfig,"
  echo "    \"angular_json\": $has_angular,"
  echo "    \"pom_xml\": $has_pom,"
  echo "    \"gradle\": $has_gradle,"
  echo "    \"gradle_kts\": $has_gradle_kts"
  echo "  },"
  echo "  \"counts\": {"
  echo "    \"ts\": $count_ts,"
  echo "    \"js\": $count_js,"
  echo "    \"java\": $count_java,"
  echo "    \"sql\": $count_sql,"
  echo "    \"docs\": $count_docs,"
  echo "    \"tests\": $count_tests"
  echo "  },"
  echo "  \"findings\": {"
  echo "    \"security\": $(join_array_json security_hits),"
  echo "    \"ai_smells\": $(join_array_json ai_smell_hits),"
  echo "    \"quality\": $(join_array_json quality_hits)"
  echo "  },"
  echo "  \"commands\": {"
  echo "    \"ran\": $(join_array_json commands_run),"
  echo "    \"output\": $(join_array_json commands_output)"
  echo "  }"
  echo "}"
} > "$JSON_TMP"

if [ -n "$OUT_PATH" ]; then
  cp "$JSON_TMP" "$OUT_PATH"
  echo "Wrote report to $OUT_PATH"
else
  cat "$JSON_TMP"
fi

popd >/dev/null
